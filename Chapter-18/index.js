




// Async JS


// Single-Threaded


// Practice: 


// 1.
/**
 * সিনক্রোনাস কোডের মধ্যে ফাঙ্কশন কল করার পর কি হবে ?
 * 
 * 
 * Ans: 
 * 
 * সিনক্রোনাস কোডে ফাঙ্কশন কল করার পর, ওই ফাঙ্কশন সম্পূর্ণভাবে এক্সিকিউট হওয়া পর্যন্ত পরবর্তী কোড এক্সিকিউট হবে না। অর্থাৎ, ফাঙ্কশনটি শেষ না হওয়া পর্যন্ত পরবর্তী লাইনের কোড ব্লক হবে।
 */




// 2.
/**
 * জাভাস্ক্রিপ্ট কি সিঙ্গেল থ্রেডেড ?
 * 
 * 
 * Ans: 
 * 
 * হ্যাঁ, জাভাস্ক্রিপ্ট সিঙ্গেল থ্রেডেড।
 */





//---------------------------------------------------------------



// Timeout

// setTimeout, setInterval


// Practice: 


// 1.
setTimeout(() => {
    console.log('I wasted 3 seconds of my life by looking at screen and doing nothing')
}, 3000)





// 2.
let strNum = 131
setInterval(() => {
    console.log(strNum)
    strNum += 2
}, 2000)




// 3.
let a = 1
const inter = setInterval(() => {
    console.log('I am learning javascript')
    if (a === 6) {
        clearInterval(inter)
    }
    a++
}, 2000)



// 4.
/**
 * setTimeout() - এর সেকেন্ড প্যারামিটার বাদ দিলে ডিফল্ট হিসেবে কত মাইক্রোসেকেন্ড ধরে নেয় ? 
 * 
 * 
 * Ans:
 * 
 * setTimeout() এর সেকেন্ড প্যারামিটার বাদ দিলে, তাহলে ডিফল্টভাবে এটি 0 মিলিসেকেন্ড (বা 0.001 সেকেন্ড) ধরে নেয়।
 */






//-------------------------------------------------------------------------






// Event loop


// 1.
/**
 * ইভেন্ট লুপ কিভাবে কাজ করে , বিস্তারিত ব্যাখ্যা কর ?
 * 
 * 
 * Ans: 
 * 
 * ইভেন্ট লুপ হল জাভাস্ক্রিপ্টের এক গুরুত্বপূর্ণ কনসেপ্ট, বিশেষত সিঙ্গেল থ্রেডেড নন-ব্লকিং আর্কিটেকচারের জন্য। এটি অ্যাসিঙ্ক্রোনাস অপারেশনগুলোকে সঠিকভাবে সম্পাদন করতে সাহায্য করে।
 * 

ইভেন্ট লুপের কাজের প্রক্রিয়া:

1. **Call Stack (কল স্ট্যাক)**:
   - এটি মূলত একটি স্ট্যাক ডেটা স্ট্রাকচার, যেখানে কোডের সিঙ্ক্রোনাস অংশগুলো এক্সিকিউট হয়।
   - যখন কোনো ফাংশন কল করা হয়, তা কল স্ট্যাকে যোগ হয় এবং এক্সিকিউট হয়। একবার কাজ শেষ হলে, এটি কল স্ট্যাক থেকে বের হয়ে যায়।

2. **Web APIs (যেমন setTimeout, fetch, DOM ইত্যাদি)**:
   - কিছু অপারেশন যেমন `setTimeout()`, `fetch()`, বা DOM ইভেন্ট হ্যান্ডলার মূল থ্রেড থেকে বের হয়ে **Web APIs** এ চলে যায়।
   - এই APIs থ্রেডের বাইরে কাজ করতে পারে এবং যখন কাজ শেষ হয়, তখন একটি কলব্যাক ফাংশন ইভেন্ট কিউতে যোগ করা হয়।

3. **Callback Queue (কলব্যাক কিউ)**:
   - ইভেন্ট কিউ এমন একটি জায়গা যেখানে অ্যাসিঙ্ক্রোনাস ফাংশনগুলো (যেমন, `setTimeout` বা `fetch` এর কলব্যাক) অপেক্ষা করে থাকে।
   - এই কিউতে থাকা ফাংশনগুলো সিস্টেমের থ্রেড যদি ফ্রি থাকে তবেই কল স্ট্যাকে যোগ হয়।

4. **Event Loop (ইভেন্ট লুপ)**:
   - ইভেন্ট লুপ হল সেই মেকানিজম যা কল স্ট্যাক এবং কলব্যাক কিউকে সিঙ্ক্রোনাইজ করে।
   - ইভেন্ট লুপ অবিরতভাবে কল স্ট্যাক চেক করে। যদি কল স্ট্যাক ফাঁকা থাকে এবং কলব্যাক কিউতে কোনো ফাংশন থাকে, তবে এটি সেই ফাংশনটিকে কল স্ট্যাকে যোগ করে। 
   - একে একে কিউ থেকে ফাংশনগুলো বের হয়ে এক্সিকিউট হয় যতক্ষণ না কিউ ফাঁকা হয়।

সহজভাবে বললে:
1. জাভাস্ক্রিপ্ট প্রথমে কল স্ট্যাকে কাজের জন্য ফাংশন যোগ করে এক্সিকিউট করে।
2. যদি কোনো অ্যাসিঙ্ক্রোনাস কাজ (যেমন `setTimeout()`, API কল ইত্যাদি) থাকে, এটি Web APIs এ চলে যায়।
3. কাজ সম্পন্ন হলে, কলব্যাক ফাংশনটি কলব্যাক কিউতে যোগ করা হয়।
4. ইভেন্ট লুপ কল স্ট্যাকের ফাঁকা থাকা দেখে কলব্যাক কিউ থেকে ফাংশনটিকে কল স্ট্যাকে নিয়ে আসে এবং এক্সিকিউট করে।

উদাহরণ:
console.log("Start");
setTimeout(() => {
  console.log("Inside setTimeout");
}, 0);
console.log("End");

এখানে, ইভেন্ট লুপের মাধ্যমে সিকোয়েন্স এমন হবে:
1. `"Start"` কনসোলে প্রিন্ট হবে।
2. `setTimeout` কল হবে, কিন্তু 0 মিলিসেকেন্ডের জন্য সেট করা থাকায় এটি সরাসরি ইভেন্ট কিউতে চলে যাবে।
3. `"End"` কনসোলে প্রিন্ট হবে।
4. কল স্ট্যাক ফাঁকা হলে, ইভেন্ট লুপ `setTimeout` এর কলব্যাক কিউ থেকে ফাংশনটি কল স্ট্যাকে নিয়ে আসবে এবং `"Inside setTimeout"` প্রিন্ট হবে।
------>
ইভেন্ট লুপের মূল কাজ হল অ্যাসিঙ্ক্রোনাস কাজগুলোকে সঠিকভাবে প্রক্রিয়া করা এবং কল স্ট্যাক ও কলব্যাক কিউকে সিঙ্ক্রোনাইজ করা। এটা নিশ্চিত করে যে একসাথে একাধিক কাজ চলার পরেও সঠিকভাবে সব ফাংশন এক্সিকিউট হয়।
 */







// 2.
/**
 * call stack আর callback queue -এর মধ্যে ডিফারেন্স কী ?
 * 
 * 
 * Ans: 
 *  
 * Call Stack 
 * কল স্ট্যাক হলো একটি লাস্ট ইন ফার্স্ট আউট (LIFO) ডেটা স্ট্রাকচার, যেখানে সিঙ্ক্রোনাস ফাংশনগুলোর এক্সিকিউশন ঘটে। 
 * যখন কোনো ফাংশন কল করা হয়, তা কল স্ট্যাকে প্রবেশ করে এবং এক্সিকিউট হয়। একবার কাজ শেষ হলে, ফাংশনটি কল স্ট্যাক থেকে বের হয়ে যায়।
 * শুধুমাত্র সিঙ্গেল থ্রেডে কাজ করে এবং এক সময় শুধুমাত্র একটি কাজ এক্সিকিউট করা যায়।
 * 
 *
 * Callback Queue
 * কলব্যাক কিউ হলো একটি ফার্স্ট ইন ফার্স্ট আউট (FIFO) ডেটা স্ট্রাকচার, যেখানে অ্যাসিঙ্ক্রোনাস ফাংশনগুলোর কলব্যাক রাখা হয়। এই কিউতে রাখা ফাংশনগুলো পরে কল স্ট্যাকের ফাঁকা হলে এক্সিকিউট হয়।
 * যখন কোনো অ্যাসিঙ্ক্রোনাস অপারেশন (যেমন setTimeout(), fetch() ইত্যাদি) সম্পন্ন হয়, তার কলব্যাক ফাংশন কলব্যাক কিউতে চলে যায়। কল স্ট্যাক ফাঁকা হলে, ইভেন্ট লুপ সেই কলব্যাক ফাংশনটিকে কল স্ট্যাকে নিয়ে আসে।
 * 
 * 
 * 
 * 
 * Call Stack হল সেই জায়গা যেখানে সিঙ্ক্রোনাস কাজগুলো এক্সিকিউট হয়, এবং Callback Queue হল সেই জায়গা যেখানে অ্যাসিঙ্ক্রোনাস কাজের কলব্যাক ফাংশনগুলো রাখা হয়, যেগুলি পরবর্তী সময়ে কল স্ট্যাকের ফাঁকা হওয়ার পর এক্সিকিউট হয়।
 */






// 3.
/**
 * জাভাস্ক্রিপ্ট যদি সিঙ্গেল থ্রেডেড হয় , তাহলে asynchronous কাজগুলো কিভাবে হ্যান্ডেল করে ?
 * 
 * 
 * Ans:
 * 
 * যেহেতু জাভাস্ক্রিপ্ট সিঙ্গেল থ্রেডেড, এটি asynchronous কাজগুলো event loop এবং callback queue ব্যবহার করে হ্যান্ডেল করে।
 * 
 * -Web APIs (যেমন setTimeout, fetch ইত্যাদি) অ্যাসিঙ্ক্রোনাস কাজ শুরু করে।
 * -কাজ শেষ হলে, সেগুলোর callback functions কলব্যাক কিউতে যোগ হয়।
 * -Event Loop কল স্ট্যাক ফাঁকা হলে কলব্যাক কিউ থেকে ফাংশনগুলি কল স্ট্যাকে নিয়ে আসে এবং এক্সিকিউট করে।
 */







//-------------------------------------------------------------------------







// Practice: 


// 1.
/**
 * জাভাস্ক্রিপ্ট কিভাবে কোড রান করে ? 
 * 
 * ব্রাউজার
 * ব্রাউজারের JavaScript Engine (যেমন, Chrome-এ V8 Engine) কোডটি পড়ে এবং রান করে।
 * 
 * Node.js
 * Node.js হল একটি JavaScript রানটাইম যা সার্ভার সাইডে JavaScript কোড রান করতে ব্যবহৃত হয়।
 * 
 */






// 2.
/**
 * What is JavaScript?
 * 
 * 
 * Ans:
 * 
 * JavaScript is a versatile, dynamically typed programming language used for interactive web applications, supporting both client-side and server-side development, and integrating seamlessly with HTML, CSS, and a rich standard library.

 -JavaScript is a single-threaded language that executes one task at a time.
 -It is an Interpreted language which means it executes the code line by line.
 -The data type of the variable is decided at run-time in JavaScript that’s why it is called dynamically typed.
 */






// 3.
/**
 * JIT compiled process বোঝানোর জন্য একটা ধাপের flowchart কোড লিখ 
 * 
 * 
 * Ans:
 * 
 * flowchart TD
    A[Source Code] --> B[Parsing]
    B --> C[Abstract Syntax Tree (AST)]
    C --> D[Bytecode Generation]
    D --> E{Is code already compiled?}
    E -->|Yes| F[Use Cached Code]
    E -->|No| G[Compile to Native Machine Code]
    G --> H[Execute Native Code]
    F --> H[Execute Cached Code]
    H --> I[Output]

 * 
    Source Code: ব্যবহারকারীর লেখা কোড।

    Parsing: কোডটি পার্স করা হয় এবং একটি AST (Abstract Syntax Tree) তৈরি করা হয়।

    AST: কোডের গঠন বা কাঠামো বোঝায়।

    Bytecode Generation: কোডের একটি মধ্যবর্তী রূপ (bytecode) তৈরি হয়।

    Is code already compiled?: চেক করা হয়, কোডটি পূর্বে কম্পাইল করা হয়েছে কিনা।

    Yes: যদি কম্পাইল করা থাকে, তাহলে ক্যাশড কোড ব্যবহার করা হয়।

    No: যদি কম্পাইল না হয়ে থাকে, তাহলে native machine code তে কম্পাইল করা হয়।

    Compile to Native Machine Code: কোডটি নেটিভ মেশিন কোডে রূপান্তরিত হয়।

    Execute Native Code: কম্পাইল করা কোডটি CPU তে রান করা হয়।

    Output: ফাইনাল আউটপুট পাওয়া যায়।
 */






// 4.
/**
 * জাভাস্ক্রিপ্ট memory management এবং garbage collection প্রসেস কিভাবে কাজ করে 
 * 
 * 
 * Ans:
 * 
 * Memory Management
 * JavaScript এর Memory Management মূলত দুইটি ধাপে কাজ করে:
 * 
 * Memory Allocation (মেমরি বরাদ্দ): যখন একটি ভ্যারিয়েবল বা অবজেক্ট তৈরি করা হয়, তখন JavaScript ইঞ্জিন সিস্টেম মেমরি থেকে একটি নির্দিষ্ট জায়গা বরাদ্দ করে।
 * 
 * Memory Deallocation (মেমরি মুক্তকরণ): যখন একটি ভ্যারিয়েবল বা অবজেক্ট আর প্রয়োজনীয় না থাকে, তখন মেমরি মুক্ত করে দেওয়া হয়, যাতে পরবর্তীতে নতুন ডেটার জন্য স্থান পাওয়া যায়।
 * 
 * 
 * 
 * Garbage Collection
 * Garbage Collection (GC) হলো একটি প্রক্রিয়া যার মাধ্যমে জাভাস্ক্রিপ্ট স্বয়ংক্রিয়ভাবে এমন অবজেক্টগুলি যা আর ব্যবহার করা হচ্ছে না, সেগুলি মুছে ফেলে। এতে মেমরি ব্যবহার কার্যকরীভাবে পরিচালিত হয় এবং মেমরি লিক (Memory Leak) রোধ করা যায়।
 * 
 * GC প্রক্রিয়া কাজ করার ধাপ
 * 
 * Mark-and-Sweep Algorithm:
 * Marking phase: গার্বেজ কালেকশন প্রথমে সমস্ত অবজেক্টের ট্র্যাক রাখে এবং চিহ্নিত করে কোন অবজেক্টগুলি অ্যাক্সেসযোগ্য, অর্থাৎ ব্যবহার করা হচ্ছে।
 * Sweeping phase: পরে, অব্যবহৃত বা অরিডিরেক্টেড অবজেক্টগুলিকে ডিলিট (মুছে) করে মেমরি মুক্ত করে।
 * 
 * Reachability:
 * একটি অবজেক্ট reachable (অথবা জীবিত) থাকে যদি তার রেফারেন্স (রেফারেন্সের মাধ্যমে অ্যাক্সেস করা যায়) কোনো এক স্থানে থেকে থাকে। যদি কোনো অবজেক্টের রেফারেন্স না থাকে, তবে সেটি গার্বেজ কালেক্টর দ্বারা মুছে ফেলা হয়।
 * 
 * 
 * Generational Garbage Collection:
 * অবজেক্টের জীবনকাল অনুযায়ী মেমরি পরিচালনা করা হয়। সাধারণত, নতুন বা সাম্প্রতিক অবজেক্টগুলিকে দ্রুত সংগ্রহ করা হয় এবং পুরোনো অবজেক্টগুলির জন্য অন্য সময়সীমায় গার্বেজ কালেকশন চলে। এটি প্রক্রিয়াটিকে দ্রুত ও কার্যকরী করে তোলে।
 */


